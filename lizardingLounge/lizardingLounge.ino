#include <WiFiManager.h>
#include <ArduinoJson.h>
// #include <Wire.h>
// #include <Adafruit_GFX.h>1
#include <Adafruit_SSD1306.h>
#include <HomeSpan.h>

// #define SCREEN_WIDTH 128 // OLED display width, in pixels
// #define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
// The pins for I2C are defined by the Wire-library.
// On an arduino UNO:       A4(SDA), A5(SCL)
// On an arduino MEGA 2560: 20(SDA), 21(SCL)
// On an arduino LEONARDO:   2(SDA),  3(SCL), ...
// #define OLED_RESET -1       // Reset pin # (or -1 if sharing Arduino reset pin)
// #define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
// Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

WebServer server(80);
JsonDocument json;
char buffer[1024];

// UV Lamp control
bool UV_LAMP = false;
const byte UV_TOGGLE_PIN = 34;
const byte UV_RELAY_PIN = 32;

// Heat Lamp control
bool HEAT_LAMP = false;
const byte HEAT_TOGGLE_PIN = 35;
const byte HEAT_RELAY_PIN = 33;

// const unsigned char light_on [] PROGMEM = {
//   // 'lightV3', 42x48px
// 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00, 
// 0x07, 0x80, 0x00, 0x00, 0x38, 0x00, 0x03, 0x80, 0x00, 0x00, 0x70, 0x00, 0x01, 0xc0, 0xff, 0xc0, 
// 0x60, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x06, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x0c, 
// 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00, 0x3d, 0xff, 0xff, 0x00, 0x00, 
// 0x00, 0x3f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x7f, 0xff, 0xff, 
// 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 
// 0xff, 0xff, 0xc0, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xc7, 0xc0, 0x78, 0xff, 0xff, 0xff, 0xc7, 0xc0, 
// 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xff, 
// 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x3f, 
// 0xff, 0xff, 0x80, 0x00, 0x00, 0x1f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 0x00, 
// 0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x07, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 
// 0x00, 0x00, 0x00, 0x03, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 
// 0xff, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 
// 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 
// 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
// };


// const unsigned char light_off [] PROGMEM = {
// // 'light_OFFV1', 42x48px
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 
// 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x1f, 
// 0x80, 0xfe, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x1f, 0x80, 0x00, 
// 0x00, 0x78, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x78, 0x00, 0x07, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x03, 
// 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x03, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x01, 0xe0, 0x00, 0x00, 0xe0, 
// 0x00, 0x01, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x01, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x01, 0xe0, 0x00, 
// 0x00, 0xe0, 0x00, 0x01, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x01, 0xe0, 0x00, 0x00, 0xf0, 0x00, 0x03, 
// 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x78, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x7c, 
// 0x00, 0x0f, 0x80, 0x00, 0x00, 0x3e, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x3f, 0x00, 0x00, 
// 0x00, 0x1f, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x07, 0xff, 0xfc, 
// 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x03, 
// 0xff, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 
// 0x00, 0x03, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x01, 0xff, 0xf0, 
// 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00
// };

// const unsigned char heat_on [] PROGMEM = {
// // 'Heat V1', 48x48px
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x7f, 0x07, 0xf0, 0x00, 0x03, 0xf0, 
// 0x3f, 0x83, 0xf8, 0x00, 0x03, 0xf8, 0x1f, 0x81, 0xf8, 0x00, 0x01, 0xf8, 0x0f, 0xc0, 0xfc, 0x00, 
// 0x00, 0xfc, 0x07, 0xe0, 0x7e, 0x00, 0x00, 0x7e, 0x07, 0xe0, 0x7e, 0x00, 0x00, 0x7e, 0x03, 0xf0, 
// 0x3f, 0x00, 0x00, 0x7e, 0x03, 0xf0, 0x3f, 0x00, 0x00, 0x7e, 0x03, 0xf0, 0x3f, 0x00, 0x00, 0x7e, 
// 0x03, 0xf0, 0x3f, 0x00, 0x00, 0x7e, 0x03, 0xf0, 0x3f, 0x00, 0x00, 0x7e, 0x07, 0xf0, 0x3f, 0x00, 
// 0x00, 0x7e, 0x07, 0xe0, 0x3f, 0x00, 0x00, 0xfe, 0x07, 0xe0, 0x7f, 0x00, 0x00, 0xfc, 0x0f, 0xe0, 
// 0x7e, 0x00, 0x01, 0xfc, 0x0f, 0xc0, 0xfe, 0x00, 0x01, 0xf8, 0x1f, 0xc0, 0xfc, 0x00, 0x03, 0xf8, 
// 0x1f, 0x81, 0xfc, 0x00, 0x03, 0xf0, 0x3f, 0x81, 0xf8, 0x00, 0x07, 0xf0, 0x3f, 0x03, 0xf8, 0x00, 
// 0x07, 0xe0, 0x3f, 0x03, 0xf0, 0x00, 0x07, 0xe0, 0x7e, 0x03, 0xf0, 0x00, 0x07, 0xe0, 0x7e, 0x03, 
// 0xf0, 0x00, 0x07, 0xe0, 0x7e, 0x03, 0xf0, 0x00, 0x07, 0xe0, 0x7e, 0x03, 0xf0, 0x00, 0x07, 0xe0, 
// 0x3f, 0x03, 0xf0, 0x00, 0x07, 0xe0, 0x3f, 0x03, 0xf0, 0x00, 0x03, 0xf0, 0x1f, 0x81, 0xf8, 0x00, 
// 0x03, 0xf0, 0x1f, 0x81, 0xf8, 0x00, 0x01, 0xf8, 0x0f, 0xc0, 0xfc, 0x00, 0x00, 0xfc, 0x07, 0xe0, 
// 0x7e, 0x00, 0x00, 0x7e, 0x03, 0xf0, 0x3f, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 
// 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 
// 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
// };

// const unsigned char heat_off [] PROGMEM = {
// // 'Heat OFF V1', 48x48px
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 
// 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 
// 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// };

void updateDisplay()
{
  Serial.println("Display temporarily disabled.");
  // display.clearDisplay();
  // display.setTextSize(1);
  // int uv_offset = 12;
  // int heat_offset = 64 + 6;

  // if (UV_LAMP)
  // {
  //   display.setCursor(uv_offset, 0);
  //   display.println("UV LAMP");
  //   display.setCursor(uv_offset + 2, 8);
  //   display.print("ACTIVE");
  //   display.drawBitmap(11, 16, light_on, 42, 48, WHITE);
  // }
  // else
  // {
  //   display.setCursor(uv_offset, 0);
  //   display.println("UV LAMP");
  //   display.setCursor(uv_offset - 4, 8);
  //   display.print("INACTIVE");
  //   display.drawBitmap(11, 16, light_off, 42, 48, WHITE);
  // }

  // if (HEAT_LAMP)
  // {
  //   display.setCursor(heat_offset, 0);
  //   display.println("HEAT LAMP");
  //   display.setCursor(heat_offset + 6, 8);
  //   display.println("ACTIVE");
  //   display.drawBitmap(72, 16, heat_on, 48, 48, WHITE);
  // }
  // else
  // {
  //   display.setCursor(heat_offset, 0);
  //   display.println("HEAT LAMP");
  //   display.setCursor(heat_offset + 2, 8);
  //   display.println("INACTIVE");
  //   display.drawBitmap(72, 16, heat_off, 48, 48, WHITE);
  // }

  // display.display();
}

void IRAM_ATTR toggle_heat()
{
  HEAT_LAMP = !HEAT_LAMP;
  if (HEAT_LAMP)
    turnOnHeat();
  else
    turnOffHeat();
}

void IRAM_ATTR toggle_uv()
{
  UV_LAMP = !UV_LAMP;
  if (UV_LAMP)
    turnOnUV();
  else
    turnOffUV();
}

bool turnOnUV()
{
  Serial.println("Turning on UV Lamp");
  UV_LAMP = true;
  digitalWrite(UV_RELAY_PIN, LOW);
  updateDisplay();
  return true;
}

bool turnOffUV()
{
  Serial.println("Turning off UV Lamp");
  UV_LAMP = false;
  digitalWrite(UV_RELAY_PIN, HIGH);
  updateDisplay();
  return true;
}

bool turnOnHeat()
{
  Serial.println("Turning on Heat Lamp");
  HEAT_LAMP = true;
  digitalWrite(HEAT_RELAY_PIN, LOW);
  updateDisplay();
  return true;
}

bool turnOffHeat()
{
  Serial.println("Turning off Heat Lamp");
  HEAT_LAMP = false;
  digitalWrite(HEAT_RELAY_PIN, HIGH);
  updateDisplay();
  return true;
}

void getAll()
{
  json.clear();
  json["uv"] = UV_LAMP;
  json["heat"] = HEAT_LAMP;
  serializeJson(json, buffer);
  server.send(200, "application/json", buffer);
}

void getUV()
{
  json.clear();
  json["uv"] = UV_LAMP;
  serializeJson(json, buffer);
  server.send(200, "application/json", buffer);
}

void getHeat()
{
  json.clear();
  json["heat"] = HEAT_LAMP;
  serializeJson(json, buffer);
  server.send(200, "application/json", buffer);
}

void enableAll()
{
  turnOnUV();
  turnOnHeat();
  server.send(200, "application/json", "{}");
}

void enableUV()
{
  turnOnUV();
  server.send(200, "application/json", "{}");
}

void enableHeat()
{
  turnOnHeat();
  server.send(200, "application/json", "{}");
}

void disableAll()
{
  turnOffUV();
  turnOffHeat();
  server.send(200, "application/json", "{}");
}

void disableUV()
{
  turnOffUV();
  server.send(200, "application/json", "{}");
}

void disableHeat()
{
  turnOffHeat();
  server.send(200, "application/json", "{}");
}

bool jsonFailure(String body)
{
  json.clear();
  DeserializationError error = deserializeJson(json, body);
  if (error)
  {
    Serial.print("deserializeJson() returned ");
    Serial.println(error.c_str());
    server.send(500, "application/json", "{\"result\":\"json failure\"}");
    return true;
  }
  return false;
}

void setupApi()
{
  server.on("/get_all", HTTP_GET, getAll);
  server.on("/get_uv", HTTP_GET, getUV);
  server.on("/get_heat", HTTP_GET, getHeat);

  server.on("/enable_all", HTTP_POST, enableAll);
  server.on("/enable_uv", HTTP_POST, enableUV);
  server.on("/enable_heat", HTTP_POST, enableHeat);

  server.on("/disable_all", HTTP_POST, disableAll);
  server.on("/disable_uv", HTTP_POST, disableUV);
  server.on("/disable_heat", HTTP_POST, disableHeat);

  server.begin();
}


void setup()
{
  // if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))
  // {
  //   Serial.println(F("SSD1306 allocation failed"));
  //   for (;;)
  //     ; // Don't proceed, loop forever
  // }
  // display.setTextColor(SSD1306_WHITE); // Draw white text

  // Serial.begin(115200);
  // delay(100);

  WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP
  // it is a good practice to make sure your code sets wifi mode how you want it.

  // WiFiManager, Local intialization. Once its business is done, there is no need to keep it around
  WiFiManager wm;

  // reset settings - wipe stored credentials for testing
  // these are stored by the esp library
  // wm.resetSettings();

  // Automatically connect using saved credentials,
  // if connection fails, it starts an access point with the specified name ( "AutoConnectAP"),
  // if empty will auto generate SSID, if password is blank it will be anonymous AP (wm.autoConnect())
  // then goes into a blocking loop awaiting configuration and will return success result

  bool res;
  // res = wm.autoConnect(); // auto generated AP name from chipid
  // res = wm.autoConnect("AutoConnectAP"); // anonymous ap
  res = wm.autoConnect("AutoConnectAP", "password"); // password protected ap

  if (!res)
  {
    Serial.println("Failed to connect");
    ESP.restart();
  }
  else
  {
    // if you get here you have connected to the WiFi
    Serial.println("Lizarding Lounge Active");
  }

  homeSpan.begin(Category::Lighting,"Lizarding Lounge");  

  // Heat Lamp
  new SpanAccessory();
    new Service::AccessoryInformation();
      new Characteristic::Identify();
      
    new Service::HeatLamp();
      new Characteristic::On(false);
    new Service::UVLamp();
      new Characteristic::On(false);

  // updateDisplay();
  setupApi();
  pinMode(UV_RELAY_PIN, OUTPUT);
  pinMode(HEAT_RELAY_PIN, OUTPUT);
  digitalWrite(UV_RELAY_PIN, HIGH);
  digitalWrite(HEAT_RELAY_PIN, HIGH);
  // pinMode(UV_TOGGLE_PIN, INPUT);
  // pinMode(HEAT_TOGGLE_PIN, INPUT);
  // attachInterrupt(digitalPinToInterrupt(UV_TOGGLE_PIN), toggle_uv, FALLING);
  // attachInterrupt(digitalPinToInterrupt(HEAT_TOGGLE_PIN), toggle_heat, FALLING);
}

void loop()
{
  server.handleClient();
  homeSpan.poll();
}